
%\section{Step}
%\input{lld/step}

\newcommand{\trans}[2]{#1 \;\; \mapsto \;\; #2}
\newcommand{\dostate}[3]{\mathtt{infer} \; #1; #2; #3}
\newcommand{\appstate}[4]{\mathtt{apply} \; #1; #2; #3; #4}
\newcommand{\rulestk}[0]{\lstack{R}}
\newcommand{\matstate}[7]{{\blacktriangleright}_{#1}^{#7} \; #2; #3; #4; #5; #6}
\newcommand{\lframe}[6]{\underset{#5 \rightarrow #6}{(#1; #2; #3; #4)}}
\newcommand{\pframe}[6]{\underset{#5 \rightarrow #6}{(#1; #2; #3; #4)}}
\newcommand{\contstate}[4]{\triangleleft_{#1} \; #2; #3; #4}
\newcommand{\failstate}[2]{\m{fail}_{#1; #2}}
\newcommand{\derstate}[4]{\curvearrowright_{#1} #2 ; #3; #4}
\newcommand{\finalstate}[3]{\circlearrowleft #1 ; #2; #3}

\subsection{Abstract Machine}
\subsubsection{States}

The available machine states are as follows:

\begin{description}
   \item[$\dostate{\Delta}{\Phi}{\Gamma}$] Executes the highest priority rule.
   \item[$\appstate{\Delta}{\Phi}{\Gamma}{R}$] Executes one rule.
   \item[$\matstate{A \lolli
      B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\Omega}{\Delta' \rightarrow
         \Omega'}$]
   Matches the body of the rule.
   \item[$\contstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}$] Restores
      matching to the next choice point of the machine.
   \item[$\derstate{\Xi}{\Gamma_1}{\Delta_1}{\Omega}$] Derives the head of the
   rule.
   \item[$\finalstate{\Xi}{\Gamma_1}{\Delta_1}$] Final state.
   \item[$\failstate{\Gamma}{\Delta}$] Fail state.
\end{description}

The machine starts with a database $(\Gamma; \Delta)$ and a queue of rules
$\Phi$. The initial state is always $\dostate{\Delta}{\Phi}{\Gamma}$.
We start by picking the first rule $R$ from $\Phi$:

\[
\trans{\dostate{\Delta}{R, \Phi}{\Gamma}}
   {\appstate{\Delta}{\Phi}{\Gamma}{R}}
\]
\[
\trans{\dostate{\Delta}{\cdot}{\Gamma}}
   {\failstate{\Gamma}{\Delta}}
\]
\[
\trans{\appstate{\Delta}{\Phi}{\Gamma}{A \lolli B}}
      {\matstate{A \lolli B}{(\Delta; \Phi)}{\cdot}{\Gamma}{\Delta}{A}{\cdot \rightarrow
                                                            \one}}
\]

\subsubsection{Matching}

Matching is the most crucial part of the machine since the derivation of the
head is trivial (except if we add comprehensions). For each atomic term in the
body we look for candidate facts in the database, add a new frame to the
continuation stack and then select the first candidate fact.

There are two types of continuation frames. Linear frames use the form
$\lframe{\Delta}{\Delta''}{p}{\Omega}{\Delta'}{\Omega}$, where:

\begin{description}
   \item[$\Delta$] Linear facts that are not candidate facts.
   \item[$\Delta''$] Candidate facts.
   \item[$p$] Linear fact to match.
   \item[$\Omega$] Rest of the body to match.
   \item[$\Delta'$] Facts consumed up-to this point.
   \item[$\Omega'$] Terms matched up-to this point using $\Delta'$.
\end{description}

Persistent frames are slightly different since they only need to keep track of
remaining persistent candidates. They are structured as $\pframe{\Gamma''}{\Delta}{\bang
   p}{\Omega}{\Delta'}{\Omega'}$:

\begin{description}
   \item[$\Gamma''$] Candidate facts.
   \item[$\Delta$] Remaining linear facts.
   \item[$\bang p$] Persistent fact to match.
   \item[$\Omega$] Rest of the body to match.
   \item[$\Delta'$] Facts consumed up-to this point.
   \item[$\Omega'$] Terms matched up-to this point using $\Delta'$.
\end{description}

A matching state is structured as $\matstate{A \lolli
   B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\Omega}{\Delta' \rightarrow
      \Omega'}$, where:

\begin{description}
   \item[$A \lolli B$] Rule being matched. $A$ is the body and $B$ the head.
   \item[$\rulestk$] Rule continuation. Contains the original $\Delta_N$ and the
   rest of the rules $\Phi$.
   \item[$\lstack{C}$] The continuation stack for matching body $A$.
   \item[$\Gamma$] persistent context.
   \item[$\Delta$] remaining linear context after matching up to this point.
   \item[$\Omega$] Rest of terms from $A$ to match.
   \item[$\Delta'$] Facts from the original $\Delta$ that were already matched
      ($\Delta', \Delta = \Delta_N$).
   \item[$\Omega'$] Parts of $A$ already matched. They are in the form $P_1
      \otimes \dotsb \otimes P_n$. The idea is to use term equivalence and the
      fact that $\feq{\Omega, \Omega'}{A}$ to justify $\mz \Gamma; \Delta'
      \rightarrow A$ when the matching process completes.
\end{description}

The first transition matches $p$ against $p_1, \Delta''$ from the database:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta, p_1, \Delta''}{p,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\matstate{A \lolli B}{\rulestk}{\lframe{\Delta,
   p_1}{\Delta''}{p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma}{\Delta,
   \Delta''}{\Omega}{\Delta', p_1 \rightarrow \Omega' \otimes p}} \;\;\; (p_1, \Delta'' \prec p)
\]

The next matches $\bang p$ against $\bang p_1, \Gamma''$ from the database:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\bang p,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\matstate{A \lolli B}{\rulestk}{\pframe{\Gamma''}{\Delta}{\bang
   p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma, p_1,
      \Gamma''}{\Delta}{\Omega}{\Delta' \rightarrow \Omega' \otimes \bang p}}
      \;\;\; (\bang p_1, \Gamma'' \prec \bang p)
\]

If we do not have facts matching $p$, we must fail:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{p,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\contstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}}
\]

Likewise, we also need to fail for $\bang p$:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\bang p,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\contstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}}
\]

The case for $\one$:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\one,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\Omega}{\Delta'
   \rightarrow \Omega'}}
\]

... and for $X \otimes Y$:

\[
\trans{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{X \otimes Y,
   \Omega}{\Delta' \rightarrow \Omega'}}
{\matstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{X, Y,
   \Omega}{\Delta' \rightarrow \Omega;}}
\]

The following transition completes the matching process:

\[
\trans{\matstate{A \lolli
   B}{\rulestk}{\lstack{C}}{\Gamma}{\Delta}{\cdot}{\Delta' \rightarrow \Omega'}}
{
   \derstate{\Delta'}{\cdot}{\cdot}{B}
}
\]

\subsubsection{Backtracking}

The backtracking state of the machine reads the top of the continuation stack
$\lstack{C}$ and restores the matching process with a different candidate fact
from the continuation frame. The state is written as $\contstate{A \lolli
   B}{\rulestk}{\lstack{C}}{\Gamma}$:

\begin{description}
   \item[$A \lolli B$] The rule being matched.
   \item[$\rulestk$] The rule continuation.
   \item[$\lstack{C}$] The continuation stack for matching body $A$.
   \item[$\Gamma$] Persistent context.
\end{description}

\[
\trans{\contstate{A \lolli B}{(\Delta; \Phi)}{\cdot}{\Gamma}}
   {\dostate{\Delta}{\Phi}{\Gamma}}
\]

\[
\trans{\contstate{A \lolli B}{\rulestk}{\lframe{\Delta}{p_2,
   \Delta''}{p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma}}
{
   \matstate{A \lolli B}{\rulestk}{\lframe{\Delta,
      p_2}{\Delta''}{p}{\Omega}{\Delta'}{\Omega'},
   \lstack{C}}{\Gamma}{\Delta}{\Omega}{\Delta', p_2 \rightarrow \Omega' \otimes p}}
\]

\[
\trans{\contstate{A \lolli
   B}{\rulestk}{\lframe{\Delta}{\cdot}{p}{\Omega}{\Delta'}{\Omega'},
      \lstack{C}}{\Gamma}}
{
   \contstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}}
\]

\[
\trans{\contstate{A \lolli B}{\rulestk}{\pframe{\bang p_2,
   \Gamma''}{\Delta}{\bang p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma}}
{
   \matstate{A \lolli B}{\rulestk}{\pframe{\Gamma''}{\Delta}{\bang
      p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma}{\Delta}{\Omega}{\Delta'
         \rightarrow \Omega' \otimes \bang p_2}}
\]

\[
\trans{\contstate{A \lolli B}{\rulestk}{\pframe{\cdot}{\Delta}{\bang
   p}{\Omega}{\Delta'}{\Omega'}, \lstack{C}}{\Gamma}}
{
   \contstate{A \lolli B}{\rulestk}{\lstack{C}}{\Gamma}}
\]

\subsubsection{Derivation}

The derivation state simply iterates over $B$, the head of the rule, and derives
terms into the corresponding new contexts. $\Xi$ represents the facts consumed
by the matching process.

\[
\trans{\derstate{\Xi}{\Gamma_1}{\Delta_1}{p, \Omega}}
{\derstate{\Xi}{\Gamma_1}{\Delta_1, p}{\Omega}}
\]

\[
\trans{\derstate{\Xi}{\Gamma_1}{\Delta_1}{\bang p, \Omega}}
{\derstate{\Xi}{\Gamma_1, \bang p}{\Delta_1}{\Omega}}
\]

\[
\trans{\derstate{\Xi}{\Gamma_1}{\Delta_1}{\one, \Omega}}
{\derstate{\Xi}{\Gamma_1}{\Delta_1}{\Omega}}
\]

\[
\trans{\derstate{\Xi}{\Gamma_1}{\Delta_1}{A \otimes B, \Omega}}
{\derstate{\Xi}{\Gamma_1}{\Delta_1}{A, B, \Omega}}
\]

\[
\trans{\derstate{\Xi}{\Gamma_1}{\Delta_1}{\cdot}}
{\finalstate{\Delta'}{\Gamma_1}{\Delta_1}}
\]

This completes the specification of the abstract machine.

\subsection{Application}

\input{lld/application}

\subsection{Match}

\input{lld/match-p}
\input{lld/match-bang-p}
\input{lld/match-other}

\subsection{Continuation}
\input{lld/cont-p}
\input{lld/cont-bang-p}
\input{lld/cont-empty}

\subsection{Derivation}
\input{lld/der-p}
\input{lld/der-other}
%\input{lld/der-comp}
%\input{lld/der-agg}
\input{lld/der-done}

\iffalse
\section{Comprehensions}
\subsection{Match}
\input{lld/comp-match-p}
\input{lld/comp-match-bang-p}
\input{lld/comp-match-other}
\input{lld/comp-match-end}

\subsection{Stack transformation}
\input{lld/comp-fix}
\input{lld/comp-stack}

\subsection{Continuation}
\input{lld/comp-cont-c}
\input{lld/comp-cont-p}
\input{lld/comp-cont-end}

\subsection{Derivation}
\input{lld/comp-der}
\input{lld/comp-der-end}

\section{Aggregates}
\subsection{Match}
\input{lld/agg-match-p}
\input{lld/agg-match-bang-p}
\input{lld/agg-match-other}
\subsection{Stack Transformation}
\input{lld/agg-fix}
\subsection{Continuation}
\input{lld/agg-cont-c}
\input{lld/agg-cont-p}
\input{lld/agg-cont-end}
\subsection{Derivation}
\input{lld/agg-der}
\fi
